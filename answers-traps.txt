1. **哪些寄存器包含函数的参数？**

   在RISC-V的调用约定中，函数的前几个整数或指针参数是按照 \(a0\)、\(a1\)、\(a2\)、\(a3\) 等的顺序传递的。如果有更多的参数不能放入这些寄存器中，则剩下的参数会被放在堆栈上。

   在`main`函数的汇编代码中，您可以看到：

   ```
   24:	4635                	li	a2,13
   26:	45b1                	li	a1,12
   ```

   这里，`a2` 被加载了值 `13`，而 `a1` 被加载了值 `12`。所以，问题 "在`main`调用`printf`时，哪个寄存器保存了13的值？" 的答案是寄存器 \(a2\)。

2. **在`main`的汇编代码中，调用函数 \(f\) 的位置在哪里？调用 \(g\) 的位置在哪里？**

   \(f\) 函数的调用不是明确存在的，这意味着它已被内联。同样，也没有直接调用 \(g\)。相反，你可以看到两个函数的操作（将参数增加3）直接在`main`函数的汇编代码中。这是从以下指令中明显的：

   ```
   14:	250d                	addw	a0,a0,3
   ```

3. **`printf` 函数位于哪个地址？**

   使用以下汇编指令调用 `printf` 函数：

   ```
   30:	00000097          	auipc	ra,0x0
   34:	600080e7          	jalr	1536(ra) # 630 <printf>
   ```

   `printf` 函数位于 `0x630` 地址。

4. **在`main`的`jalr`跳转到`printf`后，寄存器 \(ra\) 中的值是什么？**

   在RISC-V中，执行`jalr`指令后，`ra` 寄存器会保存返回地址，也就是跟在 `jalr` 之后的指令地址。在这种情况下，这个地址是 `0x38`。

5. **运行以下代码，输出是什么？**

   输出将是：`He110 World`。

6. **如果RISC-V是大端模式，为了获得相同的输出，你会将 \(i\) 设置为多少？需要将 `57616` 改为其他值吗？**

   在大端系统中，最高有效字节是首先存储的。为了得到字符串 "rld\0"，应该将 \(i\) 设置为 `0x726c6400`。不需要改变 `57616` 的值，因为它不受字节顺序的影响。

7. **在以下代码中，'y=' 后面会打印什么？为什么会这样？**

   ```c
   printf("x=%d y=%d", 3);
   ```

   `printf` 函数期望有两个整数参数（因为有两个 `%d` 格式说明符），但只提供了一个参数 `3`。'y=' 后面将打印的值是堆栈上的下一个值或下一个参数寄存器中的值，具体取决于调用约定和多少参数可以在寄存器中传递。这在C中是未定义的行为，这意味着结果可能是不可预测的，并且在不同的运行、编译器或系统之间可能会有所不同。
